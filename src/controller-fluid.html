<link rel="import" href="hash-router.html">

<dom-module id="controller-fluid">
  <template>
    <style>
      :host { display: block; }
    </style>
    <hash-router id="route" url-in="[[state.now.route.url]]"></hash-router>
    <slot></slot>
  </template>
  <script>
    class ControllerFluid extends Polymer.Element {

      static get is() {
        return "controller-fluid";
      }

      static get properties() {
        return {
          state: Object,
          route: Object,
          sketch: Object,
          viewPort: Object,
          fluidNow: {
            type: Object,
            computed: "_merge(sketch, viewPort, route)"
          },
          actionType: String
        };
      }

      constructor() {
        super();
        this.addEventListener("route-changed", this._routeChanged.bind(this));
        this.addEventListener("new-sketch", this._newSketch.bind(this));
        this.addEventListener("new-scale", this._newScale.bind(this));
        this.addEventListener("new-shape", this._newShape.bind(this));
        this.addEventListener("change-shapes", this._changeShapes.bind(this));
        this.addEventListener("change-shapes-end", this._changeShapesEnd.bind(this));
        this.addEventListener("delete-selected", this._deleteSelected.bind(this));
        this.addEventListener("deselect-all", this._deselect.bind(this));
        this.addEventListener("select", this._selectSingle.bind(this));
        this.addEventListener("new-box-selection", this._select.bind(this));
        this.addEventListener("shape-location", this._registerUIshape.bind(this));
        this.addEventListener("view-changed", this._viewChanged.bind(this));
      }

      _merge(sketch, viewPort, route) {
        if (route === undefined)               //don't merge if the route object is not instantiated
          return undefined;
        let now = {route: route};
        if (viewPort)
          now.viewPort = viewPort;
        if (sketch) {
          now.sketches = {};
          now.sketches[this.state.now.route.path.s0] = sketch;
        }
        this._fire("snap-change", {type: this.actionType, snap: now});
        return now;
      }

      _routeChanged(e) {
        e.stopPropagation();
        this.set("actionType", "route");
        //todo here we need to query the user whether or not he wants to keep the changes in the ui or start from scratch
        this.set("route", e.detail === "" ? undefined : HashRouter.parseUrl(e.detail));
      }

      _viewChanged(e) {
        e.stopPropagation();
        this.set("actionType", "view");
        this.set("viewPort", e.detail);
      }

      reset() {
        this.setProperties({
          "route": undefined,
          "sketch": undefined,
          "viewPort": undefined
        });
      }

      reduceFluid(serverNow) {
        let diffSketch = undefined;
        if (serverNow.sketches && this.state.now.route.path.s0)
          diffSketch = Tools.filterDeep(this.sketch, serverNow.sketches[this.state.now.route.path.s0]);
        let diffRoute = Tools.filterDeep(this.fluidNow.route, serverNow.route);
        if (diffSketch || diffRoute)
          this.setProperties({"sketch": diffSketch, "route": diffRoute});
      }

      _newSketch(e) {
        e.stopPropagation();
        this.set("actionType", e.type);
        console.log("The preservation of the previous state is not supported yet.");
        this.setProperties({
          "route": HashRouter.parseUrl(e.detail.url),
          "viewPort": undefined,
          "sketch": undefined
        });
      }

      _changeShapesEnd(e) {
        e.stopPropagation();
        this.set("actionType", "shape-matrix");
        this.set("sketch", Object.assign({}, this.sketch));
      }

      _changeShapes(e) {
        e.stopPropagation();
        this.set("actionType", "shape-matrix-fluid");
        this.set("sketch", Tools.mergeDeepWithNullToDelete(this.sketch, {shapes: e.detail}));
      }

      _newShape(e) {
        e.stopPropagation();
        this.set("actionType", "new-shape");
        let pos = ViewPort.calculatePositionFromCenterOfViewPort(this.state.now.viewPort, e.detail.x, e.detail.y);
        let matrix = {x: pos.x, y: pos.y, sx: 1, sy: 1, a: 0};
        this.set("sketch", Tools.setIn(this.sketch, ["shapes", Tools.genKey(), "matrix"], matrix));
      }

      _deleteSelected(e) {
        e.stopPropagation();
        this.set("actionType", "delete-shape");
        let shapes = {};
        Object.keys(this.state.selecteds).map(key => shapes[key] = null);
        this.set("sketch", Tools.mergeDeepWithNullToDelete(this.sketch, {shapes: shapes}));
      }

      _newScale(e) {
        e.stopPropagation();
        this.set("actionType", "scale");
        console.log(e);
      }

      _registerUIshape(e) {
        e.stopPropagation();
        this.set("actionType", "shape-rect");
        this.set("sketch", Tools.setIn(this.sketch, ["shapes", e.detail.key, "rect"], e.detail.value));
      }

      _deselect(e) {
        e.stopPropagation();
        this.set("actionType", "select");
        //todo alternative path might be simpler
        this.set("sketch", Tools.setInPathWithNullAsWildCard(this.sketch, ["shapes", null, "selected"], false));
      }

      _selectSingle(e) {
        e.stopPropagation();
        this.set("actionType", "select");
        this.set("sketch", Tools.setIn(this.sketch, ["shapes", e.detail, "selected"], true));
      }

      _select(e) {
        e.stopPropagation();
        this.set("actionType", "select");
        this.set("sketch", Tools.mergeDeepWithNullToDelete(this.sketch, {shapes: e.detail}));
      }

      _fire(name, detail) {
        this.dispatchEvent(new CustomEvent(name, {composed: true, bubbles: true, detail: detail}));
      }
    }
    customElements.define(ControllerFluid.is, ControllerFluid);
  </script>
</dom-module>