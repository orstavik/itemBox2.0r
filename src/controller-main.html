<link rel="import" href="controller-ui.html">
<link rel="import" href="controller-data.html">
<link rel="import" href="controller-fluid.html">
<link rel="import" href="controller-history.html">
<link rel="import" href="app-router.html">

<dom-module id="controller-main">
  <template>
    <style>
      :host { height: 100%; }
    </style>
    <app-router id="location"></app-router>
    <controller-history id="history" state="{{state}}" now="[[activeSketch]]"></controller-history>
    <controller-data id="data" state="[[state]]" fluid-active-sketch="[[state.now.fluidActiveSketch]]"
                     on-snap-change="_serverUserSnapChange"></controller-data>
    <controller-fluid id="fluid" state="[[state]]" on-snap-change="_fluidSnapChange">
      <controller-ui id="ui" state="[[state]]"></controller-ui>
    </controller-fluid>

  </template>

  <script>

    class ControllerMain extends Polymer.Element {
      static get is() {
        return "controller-main";
      }

      static get properties() {
        return {
          state: Object,
          defaultSnap: Object,
          snap: Object,
          activeSketch: {                           //partial now: the active sketch
            type: Object,
            computed: "_makeActiveSketch(snap, snap.sketches, snap.session.sketchName, snap.fluidActiveSketch, snap.selects, snap.rects)"
          },
          serverSketches: {
            type: Object,
            computed: "_getServerSketches(state.now.sketches)"
          }
        }
      }

      static get observers() {
        return ["setUrl(state.now.session.sketchName)"];
      }

      constructor() {
        super();
        this.addEventListener("new-shape", this._newShape.bind(this));
        this.addEventListener("shape-matrix-fluid", this._shapeMatrixFluid.bind(this));
        this.addEventListener("change-shapes-end", this._changeShapesEnd.bind(this));
        this.addEventListener("delete-selected", this._deleteSelected.bind(this));

        this.addEventListener("select", this._select.bind(this));
        this.addEventListener("shape-location", this._registerUIshape.bind(this));
        this.addEventListener("view-changed", this._viewChanged.bind(this));
        this.addEventListener("route-changed", this._routeChanged.bind(this));

        this.addEventListener("system-message", this._systemMessage.bind(this));
        this.addEventListener("system-error", this._systemMessage.bind(this));
        this.addEventListener("help-message", this._helpMessage.bind(this));
        this.addEventListener("sign-in", this._signIn.bind(this));
        this.addEventListener("sign-out", this._signOut.bind(this));
        this.setProperties({
          snap: {},
          defaultSnap: {viewPort: {x: 0, y: 0, s: 1}, session: {sketchName: "unsaved"}}
        });
        let startSnap = Object.assign({}, this.defaultSnap);
        startSnap.action = this.getAction("startup");
        this.set("state", {now: startSnap});
      }

      _newShape(e) {
        const newSnap = Tools.setIn(this.state.now, ["fluidActiveSketch"], e.detail);
        newSnap.action = this.getAction("new-shape");
        this.set("snap", newSnap);
      }

      _shapeMatrixFluid(e) {
        const newSnap = Tools.setIn(this.state.now, ["fluidActiveSketch"], e.detail);
        newSnap.action = this.getAction("shape-matrix-fluid");
        this.set("snap", newSnap);
      }

      _changeShapesEnd(e) {
        const newSnap = Object.assign({}, this.state.now);
        newSnap.action = this.getAction(e.detail);
        this.set("snap", newSnap);
      }

      _deleteSelected(e) {
        e.stopPropagation();
        let deletes = {};
        for (let key in this.state.now.selects)
          deletes[key] = null;
        const newSnap = Object.assign({}, this.state.now);
        newSnap.fluidActiveSketch = Tools.mergeDeepWithNullToDelete(this.state.now.fluidActiveSketch, {shapes: deletes});
        newSnap.rects = Tools.mergeDeepWithNullToDelete(this.state.now.rects, deletes);
        newSnap.selects = undefined;
        newSnap.action = this.getAction("delete-shape");
        this.set("snap", newSnap);
      }

      _newSketch(e) {
        //todo not tested in any way and we need to check whether or not we are to make a copy of the shapes we ssee on the screen, maybe keep the viewPort etc.
        let newSnap = Object.assign({}, this.defaultSnap, {session: {sketchName: e.detail.url}});
        newSnap.action = this.getAction("new-sketch");
        this.set("snap", newSnap);
      }

      getAction(action) {
        return {type: action, timeStamp: new Date().getTime()};
      }

      _makeActiveSketch(now, sketches, name, fluidActiveSketch, selects, rects) {
        if (!sketches)
          return now;
        let activeSketch = Tools.mergeDeepWithNullToDelete(sketches[name], fluidActiveSketch);
        let mergeableSelects = {};
        for (let key in selects)
          mergeableSelects[key] = {selected: true, rect: rects[key]};
        let res = Tools.mergeDeepWithNullToDelete(activeSketch, {shapes: mergeableSelects});
        now.activeSketch = res;
        return now;
      }

      _signIn() {
        this.$.data.signIn();
      }

      _signOut() {
        this.$.data.signOut();
        let newSnap = Object.assign({}, this.defaultSnap);
        newSnap.action = this.getAction("sign-out");
        this.set("snap", newSnap);
//        let defaultSnapCache = this.defaultSnap;
//        this.set("defaultSnap", undefined);          //synchronic state action start
//        this.$.data.signOut();
//        this.$.fluid.reset();
//        this.set("defaultSnap", defaultSnapCache);   //synchronic state action stop
      }

      _systemMessage(e) {
        const newSnap = Tools.setIn(this.state.now, ["systemMessage"], e.detail);
        newSnap.action = this.getAction("system-message");
        this.set("snap", newSnap);
      }

      _helpMessage(e) {
        const newSnap = Tools.setIn(this.state.now, ["helpMessage"], e.detail);
        newSnap.action = this.getAction("help-message");
        this.set("snap", newSnap);
      }

      _fluidSnapChange(e) {
        const newSnap = Tools.setIn(this.state.now, ["fluidActiveSketch"], e.detail.fluidActiveSketch);
        newSnap.action = this.getAction(e.detail.type);
        this.set("snap", newSnap);
      }

      _serverUserSnapChange(e) {
        const newSnap = Tools.mergeDeepWithNullToDelete(this.state.now, e.detail.snap);
        newSnap.action = this.getAction(e.detail.type);
        this.set("snap", newSnap);
      }

      _select(e) {
        e.stopPropagation();
        const newSnap = Tools.setIn(this.state.now, ["selects"], e.detail);
        newSnap.action = this.getAction("select");
        this.set("snap", newSnap);
      }

      _registerUIshape(e) {
        e.stopPropagation();
        const newSnap = Tools.setIn(this.state.now, ["rects", e.detail.key], e.detail.value);
        newSnap.action = this.getAction("shape-rect");
        this.set("snap", newSnap);
        //todo need to filter rects so that if matrices are removed, so will the rects be
      }

      _viewChanged(e) {
        e.stopPropagation();
        const newSnap = Tools.setIn(this.state.now, ["viewPort"], e.detail);
        newSnap.action = this.getAction("zoom");
        this.set("snap", newSnap);
      }

      _routeChanged(e) {
        e.stopPropagation();
        const newSnap = Tools.setIn(this.state.now, ["session"], e.detail && e.detail.segments ? {sketchName: e.detail.segments[0]} : {});
        newSnap.action = this.getAction("route");
        this.set("snap", newSnap);
        //todo here we need to query the user whether or not he wants to keep the changes in the ui or start from scratch
      }

      setUrl(sketchName) {
        this.$.location.setUrl("/" + sketchName);
      }

      _getServerSketches(sketches) { //todo this only filters this method to be called once for every change, not all the time..
        //debugger; //todo since polymer always runs this test even if only the parent object has changed, this will run much more often than it should..
        return sketches;
      }

    }
    customElements.define(ControllerMain.is, ControllerMain);
  </script>
</dom-module>