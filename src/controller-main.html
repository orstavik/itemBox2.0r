<link rel="import" href="controller-ui.html">
<link rel="import" href="controller-data.html">
<link rel="import" href="controller-history.html">
<link rel="import" href="app-router.html">

<dom-module id="controller-main">
  <template>
    <style>
      :host { height: 100%; }
    </style>
    <app-router id="location"></app-router>
    <controller-history id="history" state="{{state}}" now="[[activeSketch]]"></controller-history>
    <controller-data id="data" state="[[state]]"></controller-data>
    <controller-ui id="ui" state="[[state]]"></controller-ui>
  </template>
  <script>
    class ControllerMain extends Polymer.Element {
      static get is() {
        return "controller-main";
      }

      static get properties() {
        return {
          state: Object,
          defaultSnap: {
            type: Object,
            value: function () {
              return {
                viewPort: {x: 0, y: 0, s: 1},
                session: {sketchName: "unsaved"}
              };
            }
          },
          snap: Object,
          serverSketch: {
            type: Object,
            computed: "_getServerSketch(snap.sketches, snap.session.sketchName)"
          },
          activeS: {
            type: Object,
            computed: "_makeActiveS(serverSketch, snap.fluidActiveSketch)"
          },
          activeSketch: Object      //elaboration on now: the active sketch
        }
      }

      static get observers() {
        return ["setUrl(state.now.session.sketchName)",
          "_makeActiveSketch(snap, serverSketch, snap.fluidActiveSketch)"];
      }

      constructor() {
        super();
        this.addEventListener("new-user", this._newUser.bind(this));
        this.addEventListener("new-user-data", this._newUserData.bind(this));
        this.addEventListener("new-sketch-data", this._newSketchData.bind(this));

        this.addEventListener("new-shape", this._newShape.bind(this));
        this.addEventListener("change-shapes", this._changeShapes.bind(this));
        this.addEventListener("change-shapes-end", this._changeShapesEnd.bind(this));
        this.addEventListener("delete-selected", this._deleteSelected.bind(this));

        this.addEventListener("select", this._select.bind(this));
        this.addEventListener("shape-location", this._shapeLocation.bind(this));
        this.addEventListener("view-changed", this._viewChanged.bind(this));
        this.addEventListener("route-changed", this._routeChanged.bind(this));

        this.addEventListener("system-message", this._systemMessage.bind(this));
        this.addEventListener("system-error", this._systemMessage.bind(this));
        this.addEventListener("help-message", this._helpMessage.bind(this));
        this.addEventListener("sign-in", this._signIn.bind(this));
        this.addEventListener("sign-out", this._signOut.bind(this));

        this.setSnap({type: "startup", timeStamp: new Date().getTime()}, Object.assign({}, this.defaultSnap));
        this.set("state", Object.assign({}, {now: this.snap}));   //this is needed for the first route operations
      }

      _newUser(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["user"], e.detail));
      }

      _newUserData(e) {                     //todo don't really remember what this is in this app
        this.setSnap(e, Tools.mergeDeepWithNullToDelete(this.state.now, e.detail));
      }

      _newSketchData(e) {
        const newSnap = Tools.setIn(this.state.now, ["sketches"], e.detail.sketches);
        let reduced = ControllerMain.reduceFluidMatrix(this.state, e.detail);
        if (reduced) {
          newSnap.fluidActiveSketch = reduced.fluidActiveSketch;
          newSnap.rects = reduced.rects;
        }
        this.setSnap(e, newSnap);
      }

      _newShape(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["fluidActiveSketch", "shapes", Tools.genKey(), "matrix"], e.detail));
      }

      //todo now I am reducing going into controller-history. This is correct, because I want controller history to be the last and simple thing that is done to the state.
      _changeShapes(e) {
        this.setSnap(e, Tools.mergeDeepWithNullToDelete(this.state.now, {fluidActiveSketch: {shapes: e.detail}}));
      }

      _changeShapesEnd(e) {
        this.setSnap(e, Object.assign({}, this.state.now));
      }

      _deleteSelected(e) {
        let deletes = {};
        for (let key in this.state.now.selects)
          deletes[key] = null;
        const newSnap = Object.assign({}, this.state.now);
        newSnap.fluidActiveSketch = Tools.mergeDeepWithNullToDelete(this.state.now.fluidActiveSketch, {shapes: deletes});
        newSnap.rects = Tools.mergeDeepWithNullToDelete(this.state.now.rects, deletes);
        newSnap.selects = undefined;
        this.setSnap(e, newSnap);
      }

      _newSketch(e) {
        //todo not tested in any way and we need to check whether or not we are to make a copy of the shapes we see on the screen, maybe keep the viewPort etc.
        this.setSnap(e, Object.assign({}, this.defaultSnap, {session: {sketchName: e.detail.url}}));
      }

      _signIn() {
        this.$.data.signIn();
      }

      _signOut(e) {
        this.$.data.signOut();
        this.setSnap(e, Object.assign({}, this.defaultSnap));
      }

      _systemMessage(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["systemMessage"], e.detail));
      }

      _helpMessage(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["helpMessage"], e.detail));
      }

      _select(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["selects"], e.detail));
        //iterate all shapes in activeSketch, set selects = false on all of them, and select = true on the ones that are set to true in e.detail.
      }

      _shapeLocation(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["rects", e.detail.key], e.detail.value));
        //todo need to filter rects so that if matrices are removed, so will the rects be
      }

      _viewChanged(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["viewPort"], e.detail));
      }

      setUrl(sketchName) {
        this.$.location.setUrl("/" + sketchName);
      }

      setSnap(e, newSnap) {
        if (e instanceof Event)
          e.stopPropagation();
        newSnap.action = e;
        this.set("snap", newSnap);
      }

      static reduceFluidMatrix(state, serverSketches) {
        //todo here, we can also reduce the rects if we want, and yes, this we want to do!
        let diffSketch = undefined;
        if (!state.now.fluidActiveSketch)
          return undefined;
        //filter the matrices
        if (serverSketches && state.now.session.sketchName) {
          let serverSketch = serverSketches.sketches[state.now.session.sketchName];
          diffSketch = Tools.filterDeep(state.now.fluidActiveSketch, serverSketch);
          for (let key in diffSketch) { //custom algorithm for removing shapes deleted FROM server first.
            if (!serverSketch.shapes[key] && !diffSketch[key].matrix)
              delete diffSketch[key];
          }
        }
        //filter rects
        let res = {};
        for (let key in state.now.rects) {
          if (state.now.activeSketch.shapes[key])
            res[key] = state.now.rects[key];
        }
        //todo filter selects not implemented here
        return {"fluidActiveSketch": diffSketch, "rects": res};
      }

      _makeActiveSketch(now, serverSketch, fluidActiveSketch) {
        now.activeSketch = Tools.mergeDeepWithNullToDelete(serverSketch, fluidActiveSketch);
        this.set("activeSketch", now);
      }

      _getServerSketch(sketches, sketchName) {
        return sketches && sketchName ? sketches[sketchName] : undefined;
      }

      _makeActiveS(serverSketch, fluidActiveSketch) {
        return Tools.mergeDeepWithNullToDelete(serverSketch, fluidActiveSketch);
      }

      _routeChanged(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["session"], e.detail && e.detail.segments ? {sketchName: e.detail.segments[0]} : {}));
        //todo here we need to query the user whether or not he wants to keep the changes in the ui or start from scratch
        //todo NO, this we want to do before we pass this event, down in the UI. So that we at this point know from the route wether or not to copy the current active sketch or just delete it.
      }
    }
    customElements.define(ControllerMain.is, ControllerMain);
  </script>
</dom-module>