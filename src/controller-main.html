<link rel="import" href="controller-ui.html">
<link rel="import" href="controller-data.html">
<link rel="import" href="controller-history.html">
<link rel="import" href="app-router.html">

<dom-module id="controller-main">
  <template>
    <style>
      :host { height: 100%; }
    </style>
    <app-router id="location"></app-router>
    <controller-history id="history" state="{{state}}" now="[[elaborateSnap]]"></controller-history>
    <controller-data id="data" state="[[state]]"></controller-data>
    <controller-ui id="ui" state="[[state]]"></controller-ui>
  </template>
  <script>
    class ControllerMain extends Polymer.Element {
      static get is() {
        return "controller-main";
      }

      static get properties() {
        return {
          state: Object,
          defaultSnap: {
            type: Object,
            value: function () {
              return {
                viewPort: {x: 0, y: 0, s: 1},
                session: {sketchName: "unsaved"}
              };
            }
          },
          snap: Object,
          serverSketch: {
            type: Object,
            computed: "_getServerSketch(snap.sketches, snap.session.sketchName)"
          },
          activeSketch: {
            type: Object,
            computed: "_makeActiveSketch(serverSketch, snap.fluidActiveSketch)"
          },
          elaborateSnap: Object      //elaboration on now: the active sketch
        }
      }

      static get observers() {
        return [
          "setUrl(state.now.session.sketchName)",
          "_makeElaborateSnap(snap, serverSketch, activeSketch)"    //this observer runs after all the computeds are finished (at least two rounds).
        ];
      }

      constructor() {
        super();
        this.addEventListener("new-user", this._newUser.bind(this));
        this.addEventListener("new-user-data", this._newUserData.bind(this));
        this.addEventListener("new-sketch-data", this._newSketchData.bind(this));

        this.addEventListener("new-shape", this._newShape.bind(this));
        this.addEventListener("change-shapes", this._changeShapes.bind(this));
        this.addEventListener("change-shapes-end", this._changeShapesEnd.bind(this));
        this.addEventListener("delete-selected", this._deleteSelected.bind(this));

        this.addEventListener("select", this._select.bind(this));
        this.addEventListener("shape-location", this._shapeLocation.bind(this));
        this.addEventListener("view-changed", this._viewChanged.bind(this));
        this.addEventListener("route-changed", this._routeChanged.bind(this));

        this.addEventListener("system-message", this._systemMessage.bind(this));
        this.addEventListener("system-error", this._systemMessage.bind(this));
        this.addEventListener("help-message", this._helpMessage.bind(this));
        this.addEventListener("sign-in", this._signIn.bind(this));
        this.addEventListener("sign-out", this._signOut.bind(this));

        this.setSnap({type: "startup", timeStamp: new Date().getTime()}, Object.assign({}, this.defaultSnap));
        this.set("state", Object.assign({}, {now: this.snap}));   //this is needed for the first route operations
      }

      _newUser(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["user"], e.detail));
      }

      _newUserData(e) {
        this.setSnap(e, Tools.mergeDeepWithNullToDelete(this.state.now, e.detail));
      }

      _newSketchData(e) {
        const newSnap = Tools.setIn(this.state.now, ["sketches"], e.detail.sketches);
        let reduced = ControllerMain.reduceFluidMatrix(this.state, e.detail);
        if (reduced) {
          newSnap.fluidActiveSketch = reduced.fluidActiveSketch;
          newSnap.rects = reduced.rects;
          newSnap.selects = reduced.selects;
        }
        this.setSnap(e, newSnap);
      }

      _newShape(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["fluidActiveSketch", "shapes", Tools.genKey(), "matrix"], e.detail));
      }

      _changeShapes(e) {
        this.setSnap(e, Tools.mergeDeepWithNullToDelete(this.state.now, {fluidActiveSketch: {shapes: e.detail}}));
      }

      _changeShapesEnd(e) {
        this.setSnap(e, Object.assign({}, this.state.now));
      }

      _deleteSelected(e) {
        let deletes = {};
        for (let key in this.state.now.selects)
          deletes[key] = null;
        const newSnap = Object.assign({}, this.state.now);
        newSnap.fluidActiveSketch = Tools.mergeDeepWithNullToDelete(this.state.now.fluidActiveSketch, {shapes: deletes});
        newSnap.rects = Tools.mergeDeepWithNullToDelete(this.state.now.rects, deletes);
        newSnap.selects = undefined;
        this.setSnap(e, newSnap);
      }

      _newSketch(e) {
        this.setSnap(e, Object.assign({}, this.defaultSnap, {session: {sketchName: e.detail.url}}));
      }

      _signIn() {
        this.$.data.signIn();
      }

      _signOut(e) {
        this.$.data.signOut();
        this.setSnap(e, Object.assign({}, this.defaultSnap));
      }

      _systemMessage(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["systemMessage"], e.detail));
      }

      _helpMessage(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["helpMessage"], e.detail));
      }

      _select(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["selects"], e.detail));
      }

      _shapeLocation(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["rects", e.detail.key], e.detail.value));
      }

      _viewChanged(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["viewPort"], e.detail));
      }

      setUrl(sketchName) {
        this.$.location.setUrl("/" + sketchName);
      }

      setSnap(e, newSnap) {
        if (e instanceof Event)
          e.stopPropagation();
        newSnap.action = e;
        this.set("snap", newSnap);
      }

      static reduceFluidMatrix(state, serverSketches) {
        let diffSketch = undefined;
        //filter the matrices
        if (serverSketches && state.now.session.sketchName) {
          let serverSketch = serverSketches.sketches[state.now.session.sketchName];
          diffSketch = Tools.filterDeep(state.now.fluidActiveSketch, serverSketch);
          for (let key in diffSketch) { //custom algorithm for removing shapes deleted FROM server first.
            if (!serverSketch.shapes[key] && !diffSketch[key].matrix)
              delete diffSketch[key];
          }
        }
        //filter rects
        let resRects = {};
        for (let key in state.now.rects) {
          if (state.now.activeSketch.shapes[key])
            resRects[key] = state.now.rects[key];
        }
        //filter selects
        let resSelects = {};
        for (let key in state.now.selects) {
          if (state.now.activeSketch.shapes[key])
            resSelects[key] = true;
        }
        return {"fluidActiveSketch": diffSketch, "rects": resRects, "selects": resSelects};
      }

      _makeElaborateSnap(now, serverSketch, activeSketch) {
        now.activeSketch = activeSketch;
        now.serverSketch = serverSketch;
        this.set("elaborateSnap", now);
      }

      _getServerSketch(sketches, sketchName) {
        return sketches && sketchName ? sketches[sketchName] : undefined;
      }

      _makeActiveSketch(serverSketch, fluidActiveSketch) {
        return Tools.mergeDeepWithNullToDelete(serverSketch, fluidActiveSketch);
      }

      _routeChanged(e) {
        this.setSnap(e, Tools.setIn(this.state.now, ["session"], e.detail && e.detail.segments ? {sketchName: e.detail.segments[0]} : {}));
        //todo we want this event to contain already processed data about whether or not the user wants us to make a copy of the sketch or start from scratch when making the new sketch.
      }
    }
    customElements.define(ControllerMain.is, ControllerMain);
  </script>
</dom-module>