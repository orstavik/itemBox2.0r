<dom-module id="shape-box">
  <template>
    <style>
      #boxBody {
        position: absolute;
        left: 0;
        top: 0;
        border: 1px solid gray;
        pointer-events: none;
        z-index: 10;
      }
      [type=point] {
        box-sizing: border-box;
        width: 12px;
        height: 12px;
        transform: translate(-50%, -50%);
        position: absolute;
        background: white;
        border: 1px solid black;
        cursor: pointer;
        pointer-events: auto;
      }
      [type=point]:hover, [type=rotator]:hover { background: coral; }
      [type=point][active], [type=rotator][active] { background: crimson; }
      #top-left { top: 0; left: 0; }
      #top { top: 0; left: 50%; }
      #top-right { top: 0; left: 100%; }
      #right { top: 50%; left: 100%; }
      #bottom-right { top: 100%; left: 100%; }
      #bottom { top: 100%; left: 50%; }
      #bottom-left { top: 100%; left: 0; }
      #left { top: 50%; left: 0; }
      [type=rotator] {
        box-sizing: border-box;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        position: absolute;
        bottom: -40px;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        border: 1px solid black;
        cursor: pointer;
        pointer-events: auto;
      }
      [type=grabber] {
        width: 100%;
        height: 100%;
        cursor: pointer;
        pointer-events: auto;
      }
      .cross {
        box-sizing: border-box;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: black;
        pointer-events: none;
      }
      #horiz { width: 12px; height: 2px; }
      #vert { width: 2px; height: 12px; }
    </style>

    <div id="boxBody" hidden="[[empty]]" type="box">
      <div id="top-left" type="point" on-down="_startTracking" on-track="_doTracking"></div>
      <div id="top" type="point" hidden="[[multi]]" on-down="_startTracking" on-track="_doTracking"></div>
      <div id="top-right" type="point" on-down="_startTracking" on-track="_doTracking"></div>
      <div id="right" type="point" hidden="[[multi]]" on-down="_startTracking" on-track="_doTracking"></div>
      <div id="bottom-right" type="point" on-down="_startTracking" on-track="_doTracking"></div>
      <div id="bottom" type="point" hidden="[[multi]]" on-down="_startTracking" on-track="_doTracking"></div>
      <div id="bottom-left" type="point" on-down="_startTracking" on-track="_doTracking"></div>
      <div id="left" type="point" hidden="[[multi]]" on-down="_startTracking" on-track="_doTracking"></div>
      <div id="rotator" type="rotator" on-down="_startTracking" on-track="_doTracking"></div>
      <div type="grabber" on-down="_startTracking" on-track="_doTracking"></div>
      <div id="horiz" class="cross"></div>
      <div id="vert" class="cross"></div>
    </div>
  </template>

  <script>

    class ShapeBox extends Polymer.GestureEventListeners(Polymer.Element) {
      static get is() {
        return "shape-box";
      }

      static get properties() {
        return {
          shapes: {
            type: Object,
            observer: "shapesChanged"
          },
          rect: Object,
          multi: {
            type: Boolean,
            computed: "_isMulti(shapes)",
            reflectToAttribute: true
          },
          empty: {
            type: Boolean,
            computed: "_isEmpty(shapes)",
            reflectToAttribute: true
          }
        }
      }

      _isEmpty(shapes) {
        return !shapes || !Object.keys(shapes).length;
      }

      _isMulti(shapes) {
        return shapes && Object.keys(shapes).length > 1;
      }

      shapesChanged() {
        this.rect = this._makeRectangle(this.shapes);
        this._applyStyle(this.rect);
      }

      static _getFirstShape(shapes) {
        for (let key in shapes)
          return shapes[key];
      }

      _makeRectangle(shapes) {
        if (this._isEmpty(shapes))
          return undefined;
        if (this._isMulti(shapes)) {
          if (this.$.rotator.hasAttribute("active")) // BAD CODE. REFACTOR NEED!   //todo we should keep this state info in this object... maybe.. both..
            return this.rect;

          let shape = ShapeBox._getFirstShape(shapes);
          let rects = Object.keys(shapes).map(key => shapes[key].rect);
          return TransformableRectangle.makeFromManyRects(rects, shape.matrix);
        }
        let shape = ShapeBox._getFirstShape(shapes);
        return TransformableRectangle.makeFromSingleShape(shape.rect, shape.matrix);
      }

      _applyStyle(r) {
        if (!r) {
          this.$.boxBody.style.cssText = "";
        } else {
          this.$.boxBody.style.width = r.width + "px";
          this.$.boxBody.style.height = r.height + "px";
          this.$.boxBody.style.transform = "translate(" + r.left + "px," + r.top + "px) rotate(" + r.angle + "rad) scale(" + r.scale.x + "," + r.scale.y + ")";
        }
      }

      _startTracking(e) {
        e.preventDefault();
      }

      _doTracking(e) {
        e.preventDefault();
        switch (e.detail.state) {
          case 'start':
            e.currentTarget.setAttribute("active", "");
            return this._transformShapes(e.currentTarget, e.detail);
          case 'track':
            return this._transformShapes(e.currentTarget, e.detail);
          case 'end':
            e.currentTarget.removeAttribute("active");
            this.rect = this._makeRectangle(this.shapes);          //todo this might be done automatically if the shapes are coming in as binding
            this._applyStyle(this.rect);                         //todo this one too
        }
      }

      _transformShapes(target, e) {
        const ddx = e.ddx != undefined ? e.ddx : e.dx;
        const ddy = e.ddy != undefined ? e.ddy : e.dy;
        switch (target.getAttribute("type")) {
          case "grabber":
            return this._moveShapes(ddx, ddy);
          case "point":
            return this._scaleShapes(target.id, ddx, ddy, e.x, e.y);
          case "rotator":
            return this._rotateShapes(e.x, e.y, ddx, ddy);
        }
      }

      _moveShapes(x, y) {
        for (let key in this.shapes) {
          let matrix = this.shapes[key].matrix;
          matrix.x += x;
          matrix.y += y;
        }
        this._changeShapes(this.shapes);
      }

      _rotateShapes(x, y, ddx, ddy) {
        let dx = (x - ddx) - this.rect.center.x;
        let dy = (y - ddy) - this.rect.center.y;
        let a0 = Math.atan2(dx, dy);
        dx = x - this.rect.center.x;
        dy = y - this.rect.center.y;
        let a = Math.atan2(dx, dy);
        for (let key in this.shapes) {
          let matrix = this.shapes[key].matrix;
          let rect = this.shapes[key].rect;
          if (!this.multi) {
            matrix.a += a0 - a;
          } else {
            let center = rect.center;
            let rx = center.x - this.rect.center.x;
            let ry = center.y - this.rect.center.y;
            let nx = rx * Math.cos(a0 - a) - ry * Math.sin(a0 - a);
            let ny = rx * Math.sin(a0 - a) + ry * Math.cos(a0 - a);

            matrix.x += nx - rx;
            matrix.y += ny - ry;
            matrix.a += a0 - a;
          }
        }
        if (this.multi)
          this.rect.angle += a0 - a;

        this._changeShapes(this.shapes);
      }

      _scaleShapes(id, dx, dy) {
        let dir = {x: 1, y: 1};
        let ax = dx * Math.cos(-this.rect.angle) - dy * Math.sin(-this.rect.angle);
        let ay = dx * Math.sin(-this.rect.angle) + dy * Math.cos(-this.rect.angle);
        let max = ax;
        let may = ay;
        if (id.indexOf("top") != -1) {
          may = -ay;
          dir.y = -1;
        }
        if (id.indexOf("left") != -1) {
          max = -ax;
          dir.x = -1;
        }
        if (id == "top-left" || id == "top-right" || id == "bottom-right" || id == "bottom-left") {
          let prop = this.rect.height / this.rect.width;
          may = max * prop;
          ay = ax * prop * dir.x * dir.y;
        }
        else if (id == "left" || id == "right") {
          may = 0;
          ay = 0;
        }
        else if (id == "top" || id == "bottom") {
          max = 0;
          ax = 0
        }
        let nx = ax * Math.cos(this.rect.angle) - ay * Math.sin(this.rect.angle);
        let ny = ax * Math.sin(this.rect.angle) + ay * Math.cos(this.rect.angle);
        //todo above is the course of action, below is the action applied to the object??
        for (let key in this.shapes) {
          let matrix = this.shapes[key].matrix;
          let rect = this.shapes[key].rect;
          if (this.multi) {
            let center = rect.center;
            let bx, by;
            if (dir.x * this.rect.scale.x == -1)
              bx = center.x - this.rect.right;
            else
              bx = center.x - this.rect.left;
            if (dir.y * this.rect.scale.y == -1)
              by = center.y - this.rect.bottom;
            else
              by = center.y - this.rect.top;
            matrix.x += Math.abs(bx / this.rect.width) * nx;
            matrix.y += Math.abs(by / this.rect.height) * ny;

          } else {
            matrix.x += nx / 2;
            matrix.y += ny / 2;
          }
          matrix.sx *= (this.rect.scale.x * this.rect.width + max) / (this.rect.scale.x * this.rect.width);
          matrix.sy *= (this.rect.scale.y * this.rect.height + may) / (this.rect.scale.y * this.rect.height);
        }
        this._changeShapes(this.shapes);
      }

      _changeShapes(shapes) {
        this.dispatchEvent(new CustomEvent("change-shapes", {composed: true, bubbles: true, detail: shapes}));
      }
    }
    customElements.define(ShapeBox.is, ShapeBox);
  </script>
</dom-module>